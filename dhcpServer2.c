/*
 * Simple DHCP server. 
 *      -Hardwired to dole out three addresses, 192.168.0.16-18/24
 *      -'Bound' to wlan0 (so will only listen/respond on that interface
 *      -wlan0 must be set to a static ip of 192.168.0.11
 *      -Once it starts, there's no way of stopping it (endless while loop)
 *      -It only gives out an ip address to th client (not dns, gateway etc. parameters)
 * 
 * The breakthrough to making it work was to include the message....
 * 
 * // dhcp server identifier       //Need to include this, otherwise the client ignores you
 *option_ptr++ = 54;
 *option_ptr++ = 4;
 *option_ptr++ = 192;
 *option_ptr++ = 168;
 *option_ptr++ = 0;
 *option_ptr++ = 11;
 * 
 * ....in the DHCPOFFER message as part of the 'options' bytes. Without this, most clients ignore it.
 * Works with OSX and iPhone
 * 
 * There is some cleverness here:-
 *  The socket options are set such that:-
 *          -It binds to a particular interface
 *          -It is permitted to send broadcast packets
 *          -It is non blocking. (If there is no data recvfrm() will not block as normal, but will error.
 *              By reading the system variable ' errorno'  and testing for EAGAIN or EWOULDBLOCK (i.e 'would block' error),
 *              we can determine whether there is a genuine error or just no data. We can then wait a second or so
 *              and then try polling again. By waiting a second, the polling process won't be 
 *              too processor intensive
 * 
 * start the server with startDHCPServer() (which then invokes the server in a seperate thread);
 * Stop it with stopDHCPServer()
 * 
 * 
 */

//Minimal DHCP server. 
// 

//#include "dhcp_server.h"

//#include "lwip/opt.h"
//#include "lwip/arch.h"
//#include "lwip/api.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <errno.h>          //Needed to decode error messages
#include <fcntl.h>          //Needed to set the socket to be non-blocking

const int forever = 1;
int noOfAttempts = 0; //Counts the number of times the while() loop cycles

#define IPPORT_DHCPS 67
#define IPPORT_DHCPC 68

#define DHCPDISCOVER                    1
#define DHCPOFFER                       2
#define DHCPREQUEST                     3
#define DHCPACK                         5

/* 32-bit structure containing 4-digit ip number */
struct id_struct {
    uint8_t is_ip_addrs[4]; /* IP address number */
};

typedef struct {
    uint8_t dp_op; /* packet opcode type, 1 for request, 2 for reply */
    uint8_t dp_htype; /* hardware addr type , 6 for IEEE802 networks*/
    uint8_t dp_hlen; /* hardware addr length , 6 for normal mac addresses*/
    uint8_t dp_hops; /* gateway hops */
    uint32_t dp_xid; /* transaction identifier - A 32-bit identification field 
                      * generated by the client, to allow it to match up the request with replies received from DHCP servers. */
    uint16_t dp_secs; /* seconds since boot began */
    uint16_t dp_flags; /* If client doesn't yet have an address, set's bit 0 (LSB)
                        to denote that DHCP server should reply using broadcast*/
    uint8_t dp_ciaddr[4]; /* client IP address - (if already known or set), otherwise zero */
    uint8_t dp_yiaddr[4]; /* 'your' IP address -  IP address that the server is assigning to the client.*/
    uint8_t dp_siaddr[4]; /* server IP address */
    uint8_t dp_giaddr[4]; /* gateway IP address */
    uint8_t dp_chaddr[16]; /* client hardware address */
    uint8_t dp_legacy[192];
    uint8_t dp_magic[4];
    uint8_t dp_options[275]; /* options area */
    /* as of RFC2131 it is variable length */
} DHCP_TYPE;

volatile int haltServerFlag = 0; //Used to signal the server to stop
volatile int dhcpServerRunningFlag = 0; //Flags whether server is currently active or not

static int32_t DHCPSocket = -1; //Handle for the dhcp server listening socket
char magic_cookie[] = {0x63, 0x82, 0x53, 0x63}; //In decimal: 99,130,83,99

char OptionNewSubnet[] = {1, 4, 255, 255, 255, 0};
char OptionNewOffer[] = {53, 1, DHCPOFFER};
char OptionNewAck[] = {53, 1, DHCPACK};
uint8_t OptionEnd[] = {0xFF};

typedef struct { //Maintains a list of ip addresses already handed out
    uint8_t mac[6];
    uint8_t ip[4];
} DHCP_Entry_t;

#define NUM_ENTRIES 3
DHCP_Entry_t dhcpTable[NUM_ENTRIES] = {
    {
        {0, 0, 0, 0, 0, 0}, //Set 6x mac address octets to zero 
        {192, 168, 0, 16}
    },
    {
        {0, 0, 0, 0, 0, 0}, //Set 6x mac address octets to zero
        {192, 168, 0, 17}
    },
    {
        {0, 0, 0, 0, 0, 0}, //Set 6x mac address octets to zero
        {192, 168, 0, 18}
    }
};

int i;
DHCP_TYPE DHCP_Buffer;
uint8_t zeros[6] = {0, 0, 0, 0, 0, 0};

static int InventAddress(uint8_t mac[], uint8_t ip[]) {
    // search for existing
    for (i = 0; i < NUM_ENTRIES; i++) {
        if (memcmp(mac, dhcpTable[i].mac, 6) == 0) { //Use 'compare' to see if MAC table already contains the supplied mac address
            memcpy(ip, dhcpTable[i].ip, 4); //If it does, re-copy in an ip address
            return 0; //Return
        }
    }
    // create new one
    for (i = 0; i < NUM_ENTRIES; i++) {
        if (memcmp(dhcpTable[i].mac, zeros, 6) == 0) { //Or else Use 'compare' to see if MAC table is empty (i.e contains zeros)
            memcpy(dhcpTable[i].mac, mac, 6); //Copy supplied mac address into table
            memcpy(ip, dhcpTable[i].ip, 4); //Copy 
            return 0;
        }
    }
    return -1;
}

int getDhcpServerRunningStatus() {
    /*
     * Returns the current status of dhcpServerRunningFlag
     */
    return dhcpServerRunningFlag;
}

void stopDHCPServer() {
    /*
     *  Inis sets a flag (monitored by the main dhcp server while loop) to schedule
     * a shutdown oof the server. It will block until the flag is acknwoledhed and 
     * cleared.
     * 
     * It also modifies the dhcpServerRunningFlag (the only other function that 
     * should modify this global is DHCPServerThread()
     */
    if (DHCPSocket != -1) //Check socket has actually been initialised, otherwise ignore
        haltServerFlag = 1; //Set flag
    while (haltServerFlag != 0); //Now wait until main dhcp loop in DHCPServerThread() acts on and resets the flag
    dhcpServerRunningFlag = 0; //Clear flag
    //Now clear the lease table
    int i;
    for (i = 0; i < NUM_ENTRIES; i++)
        memcpy(dhcpTable[i].mac, zeros, 6);
    printf("haltServerFlag value: %d\n", haltServerFlag);
}

void printDHCPLeaseTable() {
    /*
     *  Prints the current lease table (MAC addresses and corresponding ip addresses)
     */
    //Display server status
    if (getDhcpServerRunningStatus() == 1) printf("DHCP Server running for %d seconds...\n", noOfAttempts);
    else printf("DHCP Server not running\n");

    //Display actual lease table
    int i, j;
    printf("Hardware addresss \tIP address\n");
    printf("-----------------------------------\n");
    for (i = 0; i < NUM_ENTRIES; i++) { //Iterate through table
        for (j = 0; j < 5; j++) //Display mac address of table line i
            printf("%02X:", dhcpTable[i].mac[j]); //Display mac address element j
        printf("%02X\t", dhcpTable[i].mac[5]); //Don't want colon after last octet

        //Now print corresponding ip address.
        printf("%d.%d.%d.%d\n",
                (int) dhcpTable[i].ip[0], (int) dhcpTable[i].ip[1], (int) dhcpTable[i].ip[2], (int) dhcpTable[i].ip[3]);
    }

}

void *DHCPServerThread(void *arg) {
    struct sockaddr_in myAddr;
    struct sockaddr_in sourceAddr;
    struct sockaddr_in destinationAddr;

    noOfAttempts = 0; //Counts the number of times the while() loop cycles
    int status;
    char * option_ptr;

    myAddr.sin_family = AF_INET;
    myAddr.sin_port = htons(IPPORT_DHCPS);
    myAddr.sin_addr.s_addr = INADDR_ANY;
    //myAddr.sin_addr.s_addr = AF_UNSPEC;

    //DHCPSocket = socket(AF_INET, SOCK_DGRAM, 0);
    DHCPSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //Mod by JT 6/11/16
    if (DHCPSocket < 0) printf("dhcpServer2(): socket()");
    fcntl(DHCPSocket, F_SETFL, O_NONBLOCK); //Set socket to be non-blocking (we don't want recvfrom()
    //to block, otherwise we won't be able to act on the haltServerFlag)

    //Now set socket options to allow UDP broadcast
    printf("DHCPSocket: %d\n", (int) DHCPSocket);
    int broadcast = 1;
    if ((setsockopt(DHCPSocket, SOL_SOCKET, SO_BROADCAST,
            &broadcast, sizeof broadcast)) == -1) {
        perror("setsockopt - SOL_SOCKET, SO_BROADCAST");

    }

    int sockOptRetValue = 0;
    char *devname = "wlan0";
    //char *devname = "eth0";
    
    //Now force the socket to bind to wlan0 (otherwise reply might be sent out on eth0)
    if (setsockopt(DHCPSocket, SOL_SOCKET, SO_BINDTODEVICE, devname, strlen(devname)) == -1) {
        do {
            //if (setsockopt(DHCPSocket, SOL_SOCKET, SO_BINDTODEVICE, "wlan0", 4) == -1) {
            perror("setsockopt - SOL_SOCKET, SO_BINDTODEVICE ");
            sleep(1);
            sockOptRetValue = setsockopt(DHCPSocket, SOL_SOCKET, SO_BINDTODEVICE, devname, strlen(devname));

        } while (sockOptRetValue == -1);
    }
    
    status = bind(DHCPSocket, (struct sockaddr *) &myAddr, sizeof (myAddr));
    if (status < 0) {
        printf("DHCPServerThread(): bind");
        sleep(1);
        status = bind(DHCPSocket, (struct sockaddr *) &myAddr, sizeof (myAddr));
    }
    printf("DHCPServerThread():DHCP Server started\n");

    ///This block of code polls the socket for data every second (and also monitors haltServerFlag)
    while (forever == 1) {
        status = recvfrom(DHCPSocket, (char *) &DHCP_Buffer, sizeof ( DHCP_Buffer), 0, (struct sockaddr *) &sourceAddr, 0);
        //'\33[2K\r'   //Erase existing line, move cursor to start of line
        noOfAttempts++; //Increment no. of iterarions around while loop
        //printf("Attempts: %d\n", noOfAttempts); //Display no of while{} iterations
        //printDHCPLeaseTable();

        if (status == -1) {
            int errsv = errno; //Capture error number
            //perror("recvfrom()");
            if (errsv == EAGAIN || errsv == EWOULDBLOCK) {
                //printf("recvfrom() error: EAGAIN or EWOULDBLOCK. Wait 1 second.. \n");
                sleep(1); //If recvfrom() would block, wait a second before carrying on)
            } else {
                printf("DHCPServerThread():recvfrom(): 'Unexpected' Error %d\n", errsv);
                perror("recvfrom()");
                sleep(1);
            }

        }

        if (haltServerFlag == 1) { //Has the server been signalled to stop?
            printf("haltServerFlag acknowledged\n");

            if (close(DHCPSocket) == -1) {
                perror("close(DHCPSocket)");
            } else { //close() successfully executed
                printf("socket %d successfully closed\n", DHCPSocket);
                DHCPSocket == -1; //Reset socket back to default value
                haltServerFlag = 0; //Clear flag
                break; //Break out of while loop
            }
        } else dhcpServerRunningFlag = 1; //Set flag

        //Test the incoming message type                 
        switch (DHCP_Buffer.dp_options[2]) {
            case 0:
                //Invalid value (only values 1-8 permissable according to the spec)
                break;

            case DHCPDISCOVER:
                printf("DHCP DISCOVER\n");
                printf("recvfrom:  %02X:%02X:%02X:%02X:%02X:%02X -> %d.%d.%d.%d\n",
                        DHCP_Buffer.dp_chaddr[0], DHCP_Buffer.dp_chaddr[1], DHCP_Buffer.dp_chaddr[2],
                        DHCP_Buffer.dp_chaddr[3], DHCP_Buffer.dp_chaddr[4], DHCP_Buffer.dp_chaddr[5],
                        DHCP_Buffer.dp_yiaddr[0], DHCP_Buffer.dp_yiaddr[1], DHCP_Buffer.dp_yiaddr[2], DHCP_Buffer.dp_yiaddr[3]);
                printf("DHCP_Buffer.dp_options[2]: %d\n", (int) DHCP_Buffer.dp_options[2]);
                printf("DHCP_Buffer.dp_flags: %d\n", (int) DHCP_Buffer.dp_flags);
                if (InventAddress(DHCP_Buffer.dp_chaddr, DHCP_Buffer.dp_yiaddr) == 0) { //Supply InventAddress() with received client mac address and client
                    //IP address (if it exists?) to see whether a lease for this 
                    //mac address has been offered before (if not, InventAddress() will
                    // allocate one of the remaining addresses)
                    DHCP_Buffer.dp_op = 2; // DHCP Offer has Opcode 0x02 because it's a reply         
                    DHCP_Buffer.dp_secs = 0;
                    DHCP_Buffer.dp_flags = 0;


                    //Set 'server address' field
                    DHCP_Buffer.dp_siaddr[0] = 192;
                    DHCP_Buffer.dp_siaddr[1] = 168;
                    DHCP_Buffer.dp_siaddr[2] = 0;
                    DHCP_Buffer.dp_siaddr[3] = 11;

                    memset(&DHCP_Buffer.dp_options, 0, sizeof ( DHCP_Buffer.dp_options)); //Clear memory used for options fields
                    memcpy(DHCP_Buffer.dp_magic, magic_cookie, 4); //Copy in "magic cookie"

                    char *optionsStartAddr = NULL;
                    int optionsLength = 0;
                    option_ptr = (char *) &DHCP_Buffer.dp_options; //Get pointer to 'options' block of struct
                    optionsStartAddr = option_ptr; //Capture start of options block

                    memcpy(option_ptr, OptionNewOffer, sizeof (OptionNewOffer)); //Identify message as a DHCPOFFER 
                    option_ptr += sizeof (OptionNewOffer);

                    // dhcp server identifier       //Need to include this, otherwise the client ignores you
                    *option_ptr++ = 54;
                    *option_ptr++ = 4;
                    *option_ptr++ = 192;
                    *option_ptr++ = 168;
                    *option_ptr++ = 0;
                    *option_ptr++ = 11;

                    memcpy(option_ptr, OptionNewSubnet, sizeof (OptionNewSubnet)); //
                    option_ptr += sizeof (OptionNewSubnet);

                    memcpy(option_ptr, OptionEnd, sizeof (OptionEnd));
                    option_ptr += sizeof (OptionEnd);

                    optionsLength = option_ptr - optionsStartAddr; //Calculate length of options block
                    printf("Option Block length: %d\n", optionsLength);
                    int n;
                    for (n = 0; n < optionsLength; n++) {
                        printf("%d ", ((int) *(optionsStartAddr + n))); //Print option block
                    }
                    printf("\n");

                    destinationAddr.sin_port = htons(IPPORT_DHCPC);
                    destinationAddr.sin_family = AF_INET;
                    destinationAddr.sin_addr.s_addr = INADDR_BROADCAST;

                    //Printf full DHCP/BOOTP Message
                    printf("dp_op:%d, ", DHCP_Buffer.dp_op);
                    printf("dp_htype:%d, ", DHCP_Buffer.dp_htype);
                    printf("dp_hlen:%d, ", DHCP_Buffer.dp_hlen);
                    printf("dp_hops:%d, \n", DHCP_Buffer.dp_hops);

                    printf("dp_xid:%d, ", DHCP_Buffer.dp_xid);
                    printf("dp_secs:%d, ", DHCP_Buffer.dp_secs);
                    printf("dp_flags:%d, \n", DHCP_Buffer.dp_flags);

                    printf("Client IP dp_ciaddr: %d:%d:%d:%d,  ", DHCP_Buffer.dp_ciaddr[0], DHCP_Buffer.dp_ciaddr[1], DHCP_Buffer.dp_ciaddr[2], DHCP_Buffer.dp_ciaddr[3]);
                    printf("Your IP dp_yiaddr: %d:%d:%d:%d,  ", DHCP_Buffer.dp_yiaddr[0], DHCP_Buffer.dp_yiaddr[1], DHCP_Buffer.dp_yiaddr[2], DHCP_Buffer.dp_yiaddr[3]);
                    printf("Server IP dp_siaddr: %d:%d:%d:%d,  ", DHCP_Buffer.dp_siaddr[0], DHCP_Buffer.dp_siaddr[1], DHCP_Buffer.dp_siaddr[2], DHCP_Buffer.dp_siaddr[3]);
                    printf("Gateway IP dp_giaddr: %d:%d:%d:%d\n", DHCP_Buffer.dp_giaddr[0], DHCP_Buffer.dp_giaddr[1], DHCP_Buffer.dp_giaddr[2], DHCP_Buffer.dp_giaddr[3]);
                    printf("Client hardware address dp_chaddr: %02X:%02X:%02X:%02X:%02X:%02X\n",
                            DHCP_Buffer.dp_chaddr[0], DHCP_Buffer.dp_chaddr[1], DHCP_Buffer.dp_chaddr[2],
                            DHCP_Buffer.dp_chaddr[3], DHCP_Buffer.dp_chaddr[4], DHCP_Buffer.dp_chaddr[5]);
                    printf("Magic cookie dp_magic: %02X:%02X:%02X:%02X\n", DHCP_Buffer.dp_magic[0], DHCP_Buffer.dp_magic[1], DHCP_Buffer.dp_magic[2], DHCP_Buffer.dp_magic[3]);

                    status = sendto(DHCPSocket, (char *) &DHCP_Buffer, sizeof ( DHCP_Buffer), 0, (struct sockaddr *) &destinationAddr, sizeof ( destinationAddr));
                    if (status == -1) perror("sendto()");
                    printf("sendto() bytes sent: %d\n", status);
                    printf("DHCPS: offer %02X:%02X:%02X:%02X:%02X:%02X -> %d.%d.%d.%d\n",
                            DHCP_Buffer.dp_chaddr[0], DHCP_Buffer.dp_chaddr[1], DHCP_Buffer.dp_chaddr[2],
                            DHCP_Buffer.dp_chaddr[3], DHCP_Buffer.dp_chaddr[4], DHCP_Buffer.dp_chaddr[5],
                            DHCP_Buffer.dp_yiaddr[0], DHCP_Buffer.dp_yiaddr[1], DHCP_Buffer.dp_yiaddr[2], DHCP_Buffer.dp_yiaddr[3]);


                } else {
                    printf("DHCPS: rejected discover, table full\n");
                }
                //DHCP_Buffer.dp_options[2]=0;        //Clear option message type field
                break;


            case DHCPOFFER:
                printf("DHCPOFFER. Resending offer\n");
                status = sendto(DHCPSocket, (char *) &DHCP_Buffer, sizeof ( DHCP_Buffer), 0, (struct sockaddr *) &destinationAddr, sizeof ( destinationAddr));
                if (status == -1) perror("sendto()");
                printf("sendto() bytes sent: %d\n", status);
                break;

            case DHCPREQUEST:
                printf("DHCP REQUEST\n");
                uint8_t temp[4];
                if (InventAddress(DHCP_Buffer.dp_chaddr, temp) == 0) {
                    DHCP_Buffer.dp_op = 2; // reply
                    DHCP_Buffer.dp_secs = 0;
                    DHCP_Buffer.dp_flags = 0;
                    option_ptr = (char *) &DHCP_Buffer.dp_options;
                    while (*option_ptr != 255) {
                        int len = option_ptr[1];
                        switch (*option_ptr) {
                            case 50:
                                // requested IP
                                if (len == 4) {
                                    memcpy(DHCP_Buffer.dp_yiaddr, option_ptr + 2, 4);
                                }
                                break;
                            default:
                                break;
                        }
                        option_ptr += (len + 2);
                    }
                    if (memcmp(DHCP_Buffer.dp_yiaddr, temp, 4) != 0) {
                        printf("ohoh, DHCP request did not match offer\n");
                    }
                    memcpy(DHCP_Buffer.dp_magic, magic_cookie, 4);
                    // erase and create new options
                    memset(&DHCP_Buffer.dp_options, 0, sizeof ( DHCP_Buffer.dp_options));
                    option_ptr = (char *) &DHCP_Buffer.dp_options;

                    // ACK message typ
                    *option_ptr++ = 53;
                    *option_ptr++ = 1;
                    *option_ptr++ = 5;

                    // renewal time
                    *option_ptr++ = 58;
                    *option_ptr++ = 4;
                    *option_ptr++ = 0;
                    *option_ptr++ = 0;
                    *option_ptr++ = 0x38;
                    *option_ptr++ = 0x40;

                    // rebinding time
                    *option_ptr++ = 59;
                    *option_ptr++ = 4;
                    *option_ptr++ = 0;
                    *option_ptr++ = 0;
                    *option_ptr++ = 0x62;
                    *option_ptr++ = 0x70;

                    // lease time (0x00010203 = 18 hours (66ksec)
                    *option_ptr++ = 51;
                    *option_ptr++ = 4;
                    *option_ptr++ = 0;
                    *option_ptr++ = 0;
                    *option_ptr++ = 0x70;
                    *option_ptr++ = 0x80;
                    //*option_ptr++ = 0x00;
                    //*option_ptr++ = 0x10;

                    // dhcp server identifier
                    *option_ptr++ = 54;
                    *option_ptr++ = 4;
                    *option_ptr++ = 192;
                    *option_ptr++ = 168;
                    *option_ptr++ = 0;
                    *option_ptr++ = 11;

                    // subnet mask
                    *option_ptr++ = 1;
                    *option_ptr++ = 4;
                    *option_ptr++ = 0xFF;
                    *option_ptr++ = 0xFF;
                    *option_ptr++ = 0xFF;
                    *option_ptr++ = 0x00;

                    /*                       
                     *option_ptr++ = 15; //Option message type 15 (set domain)
                                           int len = sprintf((char*) option_ptr + 1, "polecat.internal");
                     *option_ptr = (len + 1);        //Set length field
                                           option_ptr += (len + 2);
                     */
                    /*
                    // router
                     *option_ptr++ = 3;      //Option message type 03 (set default route)
                     *option_ptr++ = 4;
                     *option_ptr++ = 192;
                     *option_ptr++ = 168;
                     *option_ptr++ = 0;
                     *option_ptr++ = 11;
                     */
                    /*
                    // domain name server (DNS) //Option message type 04 (set dns)
                     *option_ptr++ = 6;
                     *option_ptr++ = 4;
                     */
                    /*
                    if (ppp_addr.dns1.addr != 0) {
                        printf("Using DNS from ppp\n");
                        uint8_t* addr = (uint8_t*) &ppp_addr.dns1.addr;
                     *option_ptr++ = addr[0];
                     *option_ptr++ = addr[1];
                     *option_ptr++ = addr[2];
                     *option_ptr++ = addr[3];
                    } else {
                     *option_ptr++ = 192;
                     *option_ptr++ = 168;
                     *option_ptr++ = 0;
                     *option_ptr++ = 11;
                    }
                     */
                    /*
                    ///////Mod by JT
                     *option_ptr++ = 192;
                     *option_ptr++ = 168;
                     *option_ptr++ = 0;
                     *option_ptr++ = 11;
                     */

                    //End of JT mod


                    // end
                    *option_ptr++ = 255;


                    destinationAddr.sin_port = htons(IPPORT_DHCPC);
                    destinationAddr.sin_family = AF_INET;
                    destinationAddr.sin_addr.s_addr = INADDR_BROADCAST;
                    sendto(DHCPSocket, (char *) &DHCP_Buffer, sizeof ( DHCP_Buffer), 0, (struct sockaddr *) &destinationAddr, sizeof ( destinationAddr));

                    printf("DHCPS: ack %02x:%02x:%02x:%02x:%02x:%02x -> %d.%d.%d.%d\n",
                            DHCP_Buffer.dp_chaddr[0], DHCP_Buffer.dp_chaddr[1], DHCP_Buffer.dp_chaddr[2],
                            DHCP_Buffer.dp_chaddr[3], DHCP_Buffer.dp_chaddr[4], DHCP_Buffer.dp_chaddr[5],
                            DHCP_Buffer.dp_yiaddr[0], DHCP_Buffer.dp_yiaddr[1], DHCP_Buffer.dp_yiaddr[2], DHCP_Buffer.dp_yiaddr[3]);
                } else {
                    printf("DHCPS: rejected Request, table full\n");
                    DHCP_Buffer.dp_options[2] = 0; //Clear option message type field
                }

                break;

            case DHCPACK:
                printf("DHCPACK received\n");
                DHCP_Buffer.dp_options[2] = 0; //Clear option message type field
                break;

            default:
                printf("DHCP unknown option %d\n", (int) DHCP_Buffer.dp_options[2]);
                //DHCP_Buffer.dp_options[2]=0;        //Clear option message type field
                break;
        }

    }
    printf("DHCP Server stopping\n");
}

int startDHCPServer() {
    //Start dhcp server as a thread
    pthread_t _dhcpServerThread;
    if (pthread_create(&_dhcpServerThread, NULL, DHCPServerThread, NULL)) {
        printf("Error creating dhcp server thread.\n");
        return -1;
    }
    while (getDhcpServerRunningStatus() == 0) { //Blocking call
        printf("startDHCPServer(): Waiting for confirmation that DHCP server has started\n");
        sleep(1);
    }
    printf("startDHCPServer(): DHCP Server has started\n");
    return 1; //Will only return once server has started
}

